# Philosocilloscope
A DIY 8-bit DAC and a visual python-based shape language library for drawing on an oscilloscope screen with an Arduino or Raspberry Pi.

![img1](/assets/2015-02-11.jpg)



![img2](/assets/2015-02-20.jpg)




## Timing
Let's see how fast the Atmega328P can draw the circle generated by the following code:


    python
    
    f = open('circleCoord.txt',mode='w')
    
    f.write('byte shapeX[] = {')
    
    for i in range(0,360,2):
        alpha=math.radians(i)
        x = int(128*math.cos(alpha)+127.5)
        if i != 358:
            f.write(str(x)+', ')
        else:
            f.write(str(x)+'};\n')
    
    f.write('byte shapeY[] = {')
    
    for i in range(0,360,2):
        alpha=math.radians(i)
        y = int(128*math.sin(alpha)+127.5)
        if i != 358:
            f.write(str(y)+', ')
        else:
            f.write(str(y)+'};\n')
    
    f.close()


| Time between crests | No. points in circle |
| ------------------- | -------------------- |
| 68 ms               | 180                  |
| 34 ms               | 90                   |
| 17 ms               | 45                   |

Bang, linear as hell! 2.65 points drawn/ms. That is BAD.

Now I'll try optimizing the code:
| Time between crests | No. points in circle |
| ------------------- | -------------------- |
|130 ms | 300|
|65 ms  | 180|
|32.5 ms | 90|
|16 ms | 45|

Goddamn, it got worse! I will need do do something better. Let's try the bitRead() function directly on the coordinate integer
| Time between crests | No. points in circle |
| ------------------- | -------------------- |
|46 ms | 300|
|24 ms | 200|
|23 ms | 180|
|16 ms | 100|
|11.5 ms | 90|
|5.8 ms | 45|

Perfect! Now I can draw 180 points without obvious jitter.

Migrating the whole shebang to Raspberry Pi2

Using the RPi.GPIO library (0.6.2) I can shift a Point in 250-275 µs, which gives ≈ 160-170 points on screen without jitter.
Shifting to the WiringPi C library (2.29) and the wiringPi-Python wrapper, I can shift a point in 450 µs, with ≈100 jitter-free on-screen points,
by using the same type of for loop I was using with RPi.GPIO.

However, if I use the built in wiringpi.shiftOut() function, which directly shifts out 8-bit integer values to the shift registers, then I can shift a Point in 50 µs, for a whopping 840 simultaneous smooth-as-velvet on-screen points!!!

I wanted to test if there was any difference in which board setup I was using, but I couldn't get the physical pin numbering setup to work for some reason, so I just stuck with the Broadcom GPIO channel numbers.

