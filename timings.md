Let's see how fast the Atmega328P can draw the circle generated by the following code:


    python
	
	f = open('circleCoord.txt',mode='w')

	f.write('byte shapeX[] = {')

	for i in range(0,360,2):
	    alpha=math.radians(i)
	    x = int(128*math.cos(alpha)+127.5)
	    if i != 358:
	        f.write(str(x)+', ')
	    else:
	        f.write(str(x)+'};\n')

	f.write('byte shapeY[] = {')

	for i in range(0,360,2):
	    alpha=math.radians(i)
	    y = int(128*math.sin(alpha)+127.5)
	    if i != 358:
	        f.write(str(y)+', ')
	    else:
	        f.write(str(y)+'};\n')

	f.close()


Time between crests | No. points in circle
---------- | --------
68 ms | 180 
34 ms | 90
17 ms | 45

Bang, linear as hell! 2.65 points drawn/ms. That is BAD.

Now I'll try optimizing the code:

130 ms | 300
65 ms  | 180
32.5 ms | 90
16 ms | 45

Goddamn, it got worse! I will need do do something better. Let's try the bitRead() function directly on the coordinate integer

46 ms | 300
24 ms | 200
23 ms | 180
16 ms | 100
11.5 ms | 90
5.8 ms | 45

Perfect! Now I can draw 180 points without obvious jitter.

Migrating the whole shebang to Raspberry Pi2

Using the RPi.GPIO library (0.6.2) I can shift a Point in 250-275 µs, which gives ≈ 160-170 points on screen without jitter.
Shifting to the WiringPi C library (2.23) and the wiringPi-Python wrapper, I can shift a point in 450 µs, with ≈100 jitter-free on-screen points,
by using the same type of for loop I was using with RPi.GPIO.

However, if I use the built in wiringpi.shiftOut() function, which directly shifts out 8-bit integer values to the shift registers, then I can shift a Point in 50 µs, for a whopping 840 simultaneous smooth-as-velvet on-screen points!!!

I wanted to test if there was any difference in which board setup I was using, but I couldn't get the physical pin numbering setup to work for some reason, so I just stuck with the Broadcom GPIO channel numbers.

